using WadSharp.Parts;

namespace WadSharp.Parsing;

/// <summary>
/// The final high level image generated by parser which can be used in the game.
/// This parser image is image of the wall, game entity, or other object.
/// </summary>
public class ParserImage
{
    private bool hasTransparency = false;
    private bool checkedForTransparency = false;

    /// <summary>
    /// Name of the image.
    /// </summary>
    public string Name { get; set; }

    /// <summary>
    /// The width of the image.
    /// </summary>
    public uint Width { get; set; }

    /// <summary>
    /// The height of the image.
    /// </summary>
    public uint Height { get; set; }

    /// <summary>
    /// The image data.
    /// </summary>
    public byte[] Data { get; set; } = Array.Empty<byte>();

    /// <summary>
    /// Returns <c>true</c> if the image has transparency, otherwise <c>false</c>.
    /// </summary>
    public bool HasTransparency
    {
        get
        {
            if (hasTransparency)
            {
                return true;
            }
            else
            {
                // Since we don't want to check it every time.
                if (!checkedForTransparency)
                {
                    checkedForTransparency = true;

                    // We need to check every 4th byte, since the image is RGBA.
                    for (int i = 0; i < Data.Length - 3; i += 4)
                    {
                        // If the alpha channel is not 255, we have transparency.
                        if (Data[i + 3] < 255)
                        {
                            hasTransparency = true;
                            break;
                        }
                    }
                }
            }
            return hasTransparency;
        }
    }

    /// <summary>
    /// Parse the <see cref="WadPictureFormat"/> list into a list of <see cref="ParserImage"/>
    /// </summary>
    /// <param name="graphics">The patches.</param>
    /// <param name="playpal">The palette.</param>
    /// <returns>The parsed images.</returns>
    public static List<ParserImage> ParsePatches(IEnumerable<WADPictureFormat> graphics, WADPlayPal playpal)
    {
        List<ParserImage> images = new();
        foreach (WADPictureFormat patch in graphics)
        {
            images.Add(ParserImage.Parse(patch, playpal));
        }
        return images;
    }

    /// <summary>
    /// Parse the <see cref="WadFlat"/> list into a list of <see cref="ParserImage"/>"
    /// </summary>
    /// <param name="flats">The flats.</param>
    /// <param name="playpal">The palette.</param>
    /// <returns>The parsed images.</returns>
    public static List<ParserImage> ParseFlats(IEnumerable<WADFlat> flats, WADPlayPal playpal)
    {
        List<ParserImage> images = new List<ParserImage>();
        foreach (WADFlat flat in flats)
        {
            images.Add(ParserImage.Parse(flat, playpal));
        }
        return images;
    }

    public static List<ParserImage> ParseTextures(
        List<WADTexture1> textures,
        WADPNames patchesNames,
        List<WADPictureFormat> pictureFormatData,
        WADPlayPal playpal)
    {
        List<ParserImage> images = new();
        foreach (WADTexture1 texture in textures)
        {
            foreach (WADTexture tex in texture.Textures)
            {
                images.Add(ParserImage.Parse(tex, patchesNames, pictureFormatData, playpal));
                images.Add(ParserImage.Parse(tex, patchesNames, pictureFormatData, playpal));
            }
        }

        return images;
    }

    public static List<ParserImage> ParseTextures(
        List<WADTexture2> textures,
        WADPNames patchesNames,
        List<WADPictureFormat> pictureFormatData,
        WADPlayPal playpal)
    {
        List<ParserImage> images = new();
        foreach (WADTexture2 texture in textures)
        {
            foreach (WADTexture tex in texture.Textures)
            {
                images.Add(Parse(tex, patchesNames, pictureFormatData, playpal));
            }
        }

        return images;
    }

    /// <summary>
    /// Parse all the textures in the level into a list of <see cref="ParserImage"/>.
    /// </summary>
    /// <param name="level">The <see cref="WADLevel"/>.</param>
    /// <returns>The list of parser images.</returns>
    public static List<ParserImage> Parse(WADLevel level)
    {
        if (level.PlayPals.Count == 0)
            throw new ArgumentException("Level must have at least one Color Palette(PlayPal) defined.");

        WADPlayPal playPal = level.PlayPals[0];

        List<ParserImage> wallTextures = ParsePatches(level.Patches, playPal);
        List<ParserImage> flatTextures = ParseFlats(level.Flats, playPal);
        List<ParserImage> textures = ParseTextures(level.Texture2s, level.PNames, level.Patches, playPal);
        List<ParserImage> textures2 = ParseTextures(level.Texture1s, level.PNames, level.Patches, playPal);

        return wallTextures
            .Concat(flatTextures)
            .Concat(textures)
            .Concat(textures2)
            .ToList();
    }

    /// <summary>
    /// Parse the <see cref="WADPictureFormat"/> into <see cref="ParserImage"/>
    /// which is just a wrapper for the image data.
    /// </summary>
    /// <param name="pictureFormat">The <see cref="WADPictureFormat"/>.</param>
    /// <param name="playpal">The color palette.</param>
    /// <returns>The <see cref="ParserImage"/>.</returns>
    public static ParserImage Parse(WADPictureFormat pictureFormat, WADPlayPal playpal)
    {
        WADColor[] data = new WADColor[pictureFormat.Width * pictureFormat.Height];
        for (int i = 0; i < data.Length; i++)
        {
            data[i] = new WADColor(0, 0, 0, 0);
        }

        // Read through the row.
        for (int x = 0; x < pictureFormat.Width; x++)
        {
            foreach (WADPictureFormatPost column in pictureFormat.Columns[x])
            {
                // Read through the column.
                int columnIndex = 0;
                int end = Math.Min(column.TopDelta + column.Length, pictureFormat.Height);
                for (int y = column.TopDelta; y < end; y++)
                {
                    // Each data pixel is an index into the Doom palette. 
                    int indexIntoDoomPalette = column.Data[columnIndex++];

                    // Get the color from the palette.
                    WADColor color = playpal.PalettesColors[indexIntoDoomPalette + column.TopDelta];
                    data[y * pictureFormat.Width + x] = color;
                }
            }
        }

        // Create the image.
        ParserImage image = new ParserImage
        {
            Name = pictureFormat.Name,
            Width = pictureFormat.Width,
            Height = pictureFormat.Height,
            Data = new byte[pictureFormat.Width * pictureFormat.Height * 4]
        };

        // Convert the data into a byte array.
        for (int i = 0; i < data.Length; i++)
        {
            // Data index.
            int d = i * 4;

            image.Data[d] = data[i].B;
            image.Data[d + 1] = data[i].G;
            image.Data[d + 2] = data[i].R;
            image.Data[d + 3] = data[i].A;
        }

        return image;
    }

    /// <summary>
    /// Parse the <see cref="WADFlat"/> into <see cref="ParserImage"/>
    /// </summary>
    /// <param name="flat">The <see cref="WADFlat"/>.</param>
    /// <param name="playpal">The palette.</param>
    /// <returns>The parsed image.</returns>
    public static ParserImage Parse(WADFlat flat, WADPlayPal playpal)
    {
        byte[] data = new byte[flat.Width * flat.Height * 4];

        int dataIndex = 0;
        foreach (int colorIndex in flat.IndicesIntoPaletteColors)
        {
            WADColor color = playpal.PalettesColors[(int)colorIndex];

            data[dataIndex++] = color.B;
            data[dataIndex++] = color.G;
            data[dataIndex++] = color.R;
            data[dataIndex++] = color.A;
        }

        return new ParserImage
        {
            Name = flat.Name,
            Width = flat.Width,
            Height = flat.Height,
            Data = data
        };
    }

    /// <summary>
    /// Parse the <see cref="WADFlat"/> into <see cref="ParserImage"/>
    /// </summary>
    /// <param name="texture">The <see cref="WADTexture"/>.</param>
    /// <param name="patchesNames">The names of patches node.</param>
    /// <param name="patches">The game patches.</param>
    /// <param name="playpal">The color palette.</param>
    /// <returns>The parsed image.</returns>
    public static ParserImage Parse(WADTexture texture, WADPNames patchesNames, List<WADPictureFormat> patches, WADPlayPal playpal)
    {
        WADColor[] data = new WADColor[texture.Width * texture.Height];
        for (int i = 0; i < data.Length; i++)
        {
            data[i] = new WADColor(0, 0, 0, 0);
        }

        // We need to apply patches to the texture.
        foreach (WADPatch patch in texture.Patches)
        {
            string patchName = patchesNames.PatchNames[patch.PatchIndex];
            WADPictureFormat? pictureFormat = patches.FirstOrDefault(x => x.Name == patchName);

            if (pictureFormat is null)
            {
                // TODO: log maybe
                continue;
            }

            // X coordinate of the texture. Must be pos offset X or 0.
            int x = Math.Max((int)patch.OriginX, 0);

            // Patch column index. If the origin is negative, we need to offset the column index.
            int patchColumnIndex = 0;
            if (patch.OriginX < 0)
            {
                patchColumnIndex = Math.Abs(patch.OriginX);
            }

            // Read through the row.
            for (; patchColumnIndex < texture.Width; patchColumnIndex++)
            {
                // If there are no more columns in a patch or x coord is greater then texture width, break.
                // So we reached either texutre limit or patch limit.
                if (x >= texture.Width || patchColumnIndex >= pictureFormat.Columns.Count)
                {
                    break;
                }

                bool isFirstColumn = true;

                foreach (WADPictureFormatPost column in pictureFormat.Columns[patchColumnIndex])
                {
                    int y = Math.Max(column.TopDelta + patch.OriginY, 0);

                    int patchRowIndex = 0;
                    if (isFirstColumn && patch.OriginY < 0)
                    {
                        patchRowIndex = Math.Abs(patch.OriginY);
                    }

                    // Read through the column.
                    for (; y < texture.Height; y++)
                    {
                        if (patchRowIndex >= column.Data.Count)
                        {
                            break;
                        }

                        // Each data pixel is an index into the Doom palette. 
                        int indexIntoDoomPalette = column.Data[patchRowIndex];

                        // Get the color from the palette.
                        WADColor color = playpal.PalettesColors[indexIntoDoomPalette];
                        int dataIndex = y * texture.Width + x;
                        data[dataIndex] = color;

                        patchRowIndex++;
                    }

                    isFirstColumn = false;
                }
                x++;

            }

        }

        // Create the image.
        ParserImage image = new()
        {
            Name = texture.Name,
            Width = (uint)texture.Width,
            Height = (uint)texture.Height,
            Data = new byte[texture.Width * texture.Height * 4]
        };

        // Convert the data into a byte array.
        for (int i = 0; i < data.Length; i++)
        {
            // Data index.
            int d = i * 4;

            image.Data[d] = data[i].B;
            image.Data[d + 1] = data[i].G;
            image.Data[d + 2] = data[i].R;
            image.Data[d + 3] = data[i].A;
        }

        return image;
    }
}